<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Game</title>
  <script>
    window.onerror = function(e, url, line){
      if (e) {
        document.getElementById('log').innerText = document.getElementById('log').innerText + '\n' + e;
      }
      
      return true; 
    }
  </script>
</head>
<body>
  <h1>Test Game 7</h1>
  <div>
    <button id='send-tx'>Send tx</button>
    <p id="balance">Balance</p>
    <p id="payment-address">Payment Address</p>

    <div id='log'></div>
  </div>
  <script>
    const DATA_NAMES = {
      BALANCE: 'balance',
      PAYMENT_ADDRESS: 'payment_andress',
      TX_PENDING_RESULT: 'tx_pending_result'
    };

    const COMMANDS = {
      SEND_TX: 'send_tx'
    };

    class IncognitoWallet {
      constructor() {
        this.balance = null;
        this.paymentAddress = null;
        this.onBalanceChangeCallback = null;
        this.onPaymentAddressChangeCallback = null;
        this.pendingRequestTxs = {};
      }

      __sendCommand(command, data) {
        // TODO: check error
        let payload;
        if (typeof command === 'string' && typeof data === 'object') {
          payload = `${command}|${JSON.stringify(data)}`;
        }

        if (payload && typeof window.ReactNativeWebView.postMessage === 'function') {
          window.ReactNativeWebView.postMessage(payload);
        }
      }

      _setData(name, data) {
        switch(name) {
          case DATA_NAMES.BALANCE:
            if (typeof data === 'number' && data >= 0 && data !== this.balance) {
              this.balance = data;

              // notify
              if (typeof this.onBalanceChangeCallback === 'function') {
                this.onBalanceChangeCallback(data);
              }
            }
            break;
          case DATA_NAMES.PAYMENT_ADDRESS:
            if (typeof data === 'string' && data !== this.paymentAddress) {
              this.paymentAddress = data;
            
              // notify
              if (typeof this.onPaymentAddressChangeCallback === 'function') {
                this.onPaymentAddressChangeCallback(data);
              }
            }
            break;
          case DATA_NAMES.TX_PENDING_RESULT:
            alert(JSON.stringify(data));
            // data: { pendingTxId: string, data: { txID: string }, error: { code: number, message: string } }
            
            if (data.pendingTxId && this.pendingRequestTxs[data.pendingTxId]) {
              if (this.pendingRequestTxs[data.pendingTxId].timeout) {
                clearTimeout(this.pendingRequestTxs[data.pendingTxId].timeout);
              }

              // success
              if (data.data) {
                this.pendingRequestTxs[data.pendingTxId].resolve(data.data);
              }

              // error
              if (data.error) {
                this.pendingRequestTxs[data.pendingTxId].reject(data.error);
              }

              delete this.pendingRequestTxs[data.pendingTxId];
            }
            break;
          default:
            return;
        }
      }

      _genPendingTxId(_id) {
        let id = _id || Date.now();
        // existed, must create new id
        if (this.pendingRequestTxs[id]) {
          id = this._genPendingTxId(id + 1);
        }

        if (!id) throw new Error('Can not generate ID for sending TX');

        return String(id);
      }

      check() {
        alert('Incognito wallet works!')
      }

      requestSendTx(toAddress, amount) {
        const pendingTxId = this._genPendingTxId();
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            delete this.pendingRequestTxs[pendingTxId];
            reject({
              code: -1,
              message: 'TX timeout'
            });
          }, 90 * 1000);
          this.__sendCommand(COMMANDS.SEND_TX, { pendingTxId, toAddress, amount });
          this.pendingRequestTxs[pendingTxId] = { resolve, reject, timeout };
        });
      }

      onBalanceChange(callback) {
        if (typeof callback === 'function') {
          this.onBalanceChangeCallback = callback;
        }
      }

      onPaymentAddressChange(callback) {
        if (typeof callback === 'function') {
          this.onPaymentAddressChangeCallback = callback;
        }
      }
    }

    const incognitoWallet = new IncognitoWallet();
    window.incognitoWallet = incognitoWallet;

    // incognitoWallet.check();

    incognitoWallet.onBalanceChange(balance => {
      const balanceEl = document.getElementById('balance');
      balanceEl.innerText = balance;
    });

    incognitoWallet.onPaymentAddressChange(paymentAddress => {
      const paymentAddressEl = document.getElementById('payment-address');
      paymentAddressEl.innerText = paymentAddress;
    });

    const sendBtnEl = document.getElementById('send-tx');
    sendBtnEl.addEventListener('click', () => {
      incognitoWallet.requestSendTx('12RtEWc7hCEmeqUSrfdsAmAsvTG1h3ZfCCtKu8gDkTnicXPSTj4ZYK8D5vh53UxRK2dqcxcEt9rKG1L5FjmXfQdhe4JDGKeiQXwFNKQ', 1)
        .then((d) => alert(d.txId))
        .catch(e => alert(e.message || e.description));
    });
  </script>
</body>
</html>