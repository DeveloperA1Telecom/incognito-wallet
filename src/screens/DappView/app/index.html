<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Game</title>
  <script>
    window.onerror = function(e, url, line){
      if (e) {
        document.getElementById('log').innerText = document.getElementById('log').innerText + '\n' + e;
      }
      
      return true; 
    }
  </script>
</head>
<body>
  <h1>Test Game 7</h1>
  <div>
    <button id='send-tx'>Send tx</button>
    <p id="balance">Balance</p>
    <p id="payment-address">Payment Address</p>
    <p id="token-list">Token List</p>

    <div id='log'></div>
  </div>
  <script>
    const DATA_NAMES = {
      BALANCE: 'balance',
      PAYMENT_ADDRESS: 'payment_andress',
      TX_PENDING_RESULT: 'tx_pending_result',
      LIST_TOKEN: 'list_token'
    };

    const COMMANDS = {
      SEND_TX: 'send_tx',
      SELECT_PRIVACY_TOKEN_BY_ID: 'select_privacy_token_by_id'
    };

    class IncognitoWallet {
      constructor() {
        this.balance = null;
        this.paymentAddress = null;
        this.onBalanceChangeCallback = null;
        this.onPaymentAddressChangeCallback = null;
        this.onSupportedTokenListChangeCallback = null;
        this.pendingRequestTxs = {};
        this.supportedTokenList = [];
      }

      __sendCommand(command, data) {
        // TODO: check error
        let payload;
        if (typeof command === 'string' && typeof data === 'object') {
          payload = `${command}|${JSON.stringify(data)}`;
        } else {
          throw new Errro('__sendCommand with invalid params: "command" must be a tring, "data" must be an object');
        }

        if (payload && typeof window.ReactNativeWebView.postMessage === 'function') {
          window.ReactNativeWebView.postMessage(payload);
        } else {
          alert('Can not send command');
        }
      }

      _setData(name, data) {
        switch(name) {
          case DATA_NAMES.BALANCE:
            if (typeof data === 'number' && data >= 0 && data !== this.balance) {
              // nothing to update
              if (this.balance === data) return;

              this.balance = data;

              // notify
              if (typeof this.onBalanceChangeCallback === 'function') {
                this.onBalanceChangeCallback(data);
              }
            }
            break;
          case DATA_NAMES.PAYMENT_ADDRESS:
            if (typeof data === 'string' && data !== this.paymentAddress) {
              // nothing to update
              if (this.paymentAddress === data) return;

              this.paymentAddress = data;
            
              // notify
              if (typeof this.onPaymentAddressChangeCallback === 'function') {
                this.onPaymentAddressChangeCallback(data);
              }
            }
            break;
          case DATA_NAMES.TX_PENDING_RESULT:
            // data: { pendingTxId: string, data: { txID: string }, error: { code: number, message: string } }
            if (data.pendingTxId && this.pendingRequestTxs[data.pendingTxId]) {
              if (this.pendingRequestTxs[data.pendingTxId].timeout) {
                clearTimeout(this.pendingRequestTxs[data.pendingTxId].timeout);
              }

              // success
              if (data.data) {
                this.pendingRequestTxs[data.pendingTxId].resolve(data.data);
              }

              // error
              if (data.error) {
                this.pendingRequestTxs[data.pendingTxId].reject(data.error);
              }

              delete this.pendingRequestTxs[data.pendingTxId];
            }
            break;
          case DATA_NAMES.LIST_TOKEN:
            // data: Array of { [tokenID]: [tokenSymbol] }
            if (data instanceof Array) {
              // nothing to update
              if ((this.supportedTokenList && this.supportedTokenList.length) === (data && data.length)) return;

              this.supportedTokenList = data;
            
              // notify
              if (typeof this.onSupportedTokenListChangeCallback === 'function') {
                this.onSupportedTokenListChangeCallback(data);
              }
            }
          default:
            return;
        }
      }

      _genPendingTxId(_id) {
        let id = _id || Date.now();
        // existed, must create new id
        if (this.pendingRequestTxs[id]) {
          id = this._genPendingTxId(id + 1);
        }

        if (!id) throw new Error('Can not generate ID for sending TX');

        return String(id);
      }

      check() {
        alert('Incognito wallet works!')
      }

      changePrivacyTokenById = tokenID => {
        if (typeof tokenID !== 'string') {
          alert(tokenID);
          throw new Error('tokenID must be a string');
        }

        this.__sendCommand(COMMANDS.SELECT_PRIVACY_TOKEN_BY_ID, { tokenID });
      }

      requestSendTx(toAddress, amount) {
        if (typeof toAddress !== 'string') throw new Error('toAddress must be a string');
        if (typeof amount !== 'number' && amount <= 0) throw new Error('invalid amount');

        const pendingTxId = this._genPendingTxId();
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            delete this.pendingRequestTxs[pendingTxId];
            reject({
              code: 'send_tx_timeout',
              message: 'TX timeout'
            });
          }, 90 * 1000);
          this.__sendCommand(COMMANDS.SEND_TX, { pendingTxId, toAddress, amount });
          this.pendingRequestTxs[pendingTxId] = { resolve, reject, timeout };
        });
      }

      onBalanceChange(callback) {
        if (typeof callback === 'function') {
          this.onBalanceChangeCallback = callback;
        }
      }

      onPaymentAddressChange(callback) {
        if (typeof callback === 'function') {
          this.onPaymentAddressChangeCallback = callback;
        }
      }

      onSupportedTokenListChange(callback) {
        if (typeof callback === 'function') {
          this.onSupportedTokenListChangeCallback = callback;
        }
      }
    }

    const incognitoWallet = new IncognitoWallet();
    window.incognitoWallet = incognitoWallet;

    // incognitoWallet.check();

    incognitoWallet.onBalanceChange(balance => {
      alert('balance was updated');
      const balanceEl = document.getElementById('balance');
      balanceEl.innerText = balance;
    });

    incognitoWallet.onPaymentAddressChange(paymentAddress => {
      alert('paymentAddress was updated');
      const paymentAddressEl = document.getElementById('payment-address');
      paymentAddressEl.innerText = paymentAddress;
    });

    incognitoWallet.onSupportedTokenListChange(tokenList => {
      alert('onSupportedTokenListChange was updated');
      const tokenListEl = document.getElementById('token-list');
      tokenListEl.innerText = JSON.stringify(tokenList);

      const ids = tokenList.map(Object.keys);

      setTimeout(() => {
        incognitoWallet.changePrivacyTokenById(String(ids[1]));
      }, 5000);
    });

    const sendBtnEl = document.getElementById('send-tx');
    sendBtnEl.addEventListener('click', () => {
      incognitoWallet.requestSendTx('12RtEWc7hCEmeqUSrfdsAmAsvTG1h3ZfCCtKu8gDkTnicXPSTj4ZYK8D5vh53UxRK2dqcxcEt9rKG1L5FjmXfQdhe4JDGKeiQXwFNKQ', 1)
        .then((d) => alert(d.txId))
        .catch(e => alert(`${e.code} ${e.message || e.description}`));
    });
  </script>
</body>
</html>